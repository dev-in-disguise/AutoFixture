using System.Diagnostics.CodeAnalysis;

namespace AutoFixture.TUnit
{
    /// <summary>
    /// Provides a data source for a data theory, with the data coming from inline
    /// values combined with auto-generated data specimens generated by AutoFixture.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    [CLSCompliant(false)]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes",
        Justification = "This attribute is the root of a potential attribute hierarchy.")]
    [SuppressMessage("Usage", "TUnit0028:AttributeUsage Overridden")]
    public class InlineAutoDataAttribute<T> : DataSourceGeneratorAttribute<T>
    {
        private readonly T? dataOfT;
        private readonly Lazy<IFixture> fixtureLazy;

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This constructor overload initializes the <see cref="Fixture"/> to an instance of
        /// <see cref="Fixture"/>.
        /// </para>
        /// </remarks>
        public InlineAutoDataAttribute(T? dataOfT = default)
            : this(() => new Fixture(), dataOfT)
        {
        }


        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class
        /// with the supplied <paramref name="fixtureFactory"/>. Fixture will be created
        /// on demand using the provided factory.
        /// </summary>
        /// <param name="fixtureFactory">The fixture factory used to construct the fixture.</param>
        protected InlineAutoDataAttribute(Func<IFixture> fixtureFactory, T? dataOfT = default)
        {
            if (fixtureFactory == null) throw new ArgumentNullException(nameof(fixtureFactory));
            this.dataOfT = dataOfT;

            this.fixtureLazy = new Lazy<IFixture>(fixtureFactory, LazyThreadSafetyMode.PublicationOnly);
        }

        public override IEnumerable<T> GenerateDataSources(DataGeneratorMetadata metadata)
        {
            ArgumentNullException.ThrowIfNull(metadata.ParameterInfos);
            if (metadata.ParameterInfos.Length == 0)
            {
                return Enumerable.Empty<T>();
            }
            // todo: validate parameterinfos against generic types
            if (!EqualityComparer<T>.Default.Equals(this.dataOfT, default))
            {
                return [this.dataOfT!];
            }

            return DataSourceGenerator.GenerateDataSources(metadata.ParameterInfos.Select(s => new GeneratedParameterMetadata(s)).ToArray<ParameterMetadata>(), this.fixtureLazy.Value).Cast<T>();
        }
    }
    
    /// <summary>
    /// Provides a data source for a data theory, with the data coming from inline
    /// values combined with auto-generated data specimens generated by AutoFixture.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    [CLSCompliant(false)]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes",
        Justification = "This attribute is the root of a potential attribute hierarchy.")]
    [SuppressMessage("Usage", "TUnit0028:AttributeUsage Overridden")]
    public class InlineAutoDataAttribute<T1, T2> : DataSourceGeneratorAttribute<T1, T2>
    {
        private readonly T1? dataOfT1;
        private readonly T2? dataOfT2;
        private readonly Lazy<IFixture> fixtureLazy;

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This constructor overload initializes the <see cref="Fixture"/> to an instance of
        /// <see cref="Fixture"/>.
        /// </para>
        /// </remarks>
        public InlineAutoDataAttribute(T1? dataOfT1 = default, T2? dataOfT2 = default)
            : this(() => new Fixture(), dataOfT1, dataOfT2)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class
        /// with the supplied <paramref name="fixtureFactory"/>. Fixture will be created
        /// on demand using the provided factory.
        /// </summary>
        /// <param name="fixtureFactory">The fixture factory used to construct the fixture.</param>
        /// <param name="dataOfT1"></param>
        /// <param name="dataOfT2"></param>
        protected InlineAutoDataAttribute(Func<IFixture> fixtureFactory, T1? dataOfT1 = default, T2? dataOfT2 = default)
        {
            if (fixtureFactory == null) throw new ArgumentNullException(nameof(fixtureFactory));
            this.dataOfT1 = dataOfT1;
            this.dataOfT2 = dataOfT2;

            this.fixtureLazy = new Lazy<IFixture>(fixtureFactory, LazyThreadSafetyMode.PublicationOnly);
        }

        public override IEnumerable<(T1, T2)> GenerateDataSources(DataGeneratorMetadata metadata)
        {
            ArgumentNullException.ThrowIfNull(metadata.ParameterInfos);
            if (metadata.ParameterInfos.Length == 0)
            {
                return Enumerable.Empty<(T1, T2)>();
            }
            // todo: validate parameterinfos against generic types
            var parameters = new ParameterMetadata[metadata.ParameterInfos.Length];
            
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[0], ref parameters[0], this.dataOfT1);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[1], ref parameters[1], this.dataOfT2);
            
            object[] dataSources = DataSourceGenerator.GenerateDataSources(parameters, this.fixtureLazy.Value);

            return [((T1)dataSources[0], (T2)dataSources[1])];
        }
    }
    
    /// <summary>
    /// Provides a data source for a data theory, with the data coming from inline
    /// values combined with auto-generated data specimens generated by AutoFixture.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    [CLSCompliant(false)]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes",
        Justification = "This attribute is the root of a potential attribute hierarchy.")]
    [SuppressMessage("Usage", "TUnit0028:AttributeUsage Overridden")]
    public class InlineAutoDataAttribute<T1, T2, T3> : DataSourceGeneratorAttribute<T1, T2, T3>
    {
        private readonly T3? dataOfT3;
        private readonly T1? dataOfT1;
        private readonly T2? dataOfT2;
        private readonly Lazy<IFixture> fixtureLazy;

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This constructor overload initializes the <see cref="Fixture"/> to an instance of
        /// <see cref="Fixture"/>.
        /// </para>
        /// </remarks>
        public InlineAutoDataAttribute(T1? dataOfT1 = default, T2? dataOfT2 = default, T3? dataOfT3 = default)
            : this(() => new Fixture(), dataOfT1, dataOfT2, dataOfT3)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class
        /// with the supplied <paramref name="fixtureFactory"/>. Fixture will be created
        /// on demand using the provided factory.
        /// </summary>
        /// <param name="fixtureFactory">The fixture factory used to construct the fixture.</param>
        /// <param name="dataOfT1"></param>
        /// <param name="dataOfT2"></param>
        protected InlineAutoDataAttribute(Func<IFixture> fixtureFactory, T1? dataOfT1 = default, T2? dataOfT2 = default, T3? dataOfT3 = default)
        {
            if (fixtureFactory == null) throw new ArgumentNullException(nameof(fixtureFactory));
            this.dataOfT1 = dataOfT1;
            this.dataOfT2 = dataOfT2;
            this.dataOfT3 = dataOfT3;

            this.fixtureLazy = new Lazy<IFixture>(fixtureFactory, LazyThreadSafetyMode.PublicationOnly);
        }

        public override IEnumerable<(T1, T2, T3)> GenerateDataSources(DataGeneratorMetadata metadata)
        {
            ArgumentNullException.ThrowIfNull(metadata.ParameterInfos);
            if (metadata.ParameterInfos.Length == 0)
            {
                return Enumerable.Empty<(T1, T2, T3)>();
            }
            // todo: validate parameterinfos against generic types
            var parameters = new ParameterMetadata[metadata.ParameterInfos.Length];
            
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[0], ref parameters[0], this.dataOfT1);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[1], ref parameters[1], this.dataOfT2);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[2], ref parameters[2], this.dataOfT3);
            
            object[] dataSources = DataSourceGenerator.GenerateDataSources(parameters, this.fixtureLazy.Value);

            return [((T1)dataSources[0], (T2)dataSources[1], (T3)dataSources[2])];
        }
    }
    
    /// <summary>
    /// Provides a data source for a data theory, with the data coming from inline
    /// values combined with auto-generated data specimens generated by AutoFixture.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    [CLSCompliant(false)]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes",
        Justification = "This attribute is the root of a potential attribute hierarchy.")]
    [SuppressMessage("Usage", "TUnit0028:AttributeUsage Overridden")]
    public class InlineAutoDataAttribute<T1, T2, T3, T4> : DataSourceGeneratorAttribute<T1, T2, T3, T4>
    {
        private readonly T3? dataOfT3;
        private readonly T4? dataOfT4;
        private readonly T1? dataOfT1;
        private readonly T2? dataOfT2;
        private readonly Lazy<IFixture> fixtureLazy;

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This constructor overload initializes the <see cref="Fixture"/> to an instance of
        /// <see cref="Fixture"/>.
        /// </para>
        /// </remarks>
        public InlineAutoDataAttribute(T1? dataOfT1 = default, T2? dataOfT2 = default, T3? dataOfT3 = default, T4? dataOfT4 = default)
            : this(() => new Fixture(), dataOfT1, dataOfT2, dataOfT3)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class
        /// with the supplied <paramref name="fixtureFactory"/>. Fixture will be created
        /// on demand using the provided factory.
        /// </summary>
        /// <param name="fixtureFactory">The fixture factory used to construct the fixture.</param>
        /// <param name="dataOfT1"></param>
        /// <param name="dataOfT2"></param>
        protected InlineAutoDataAttribute(Func<IFixture> fixtureFactory, T1? dataOfT1 = default, T2? dataOfT2 = default, T3? dataOfT3 = default, T4? dataOfT4 = default)
        {
            if (fixtureFactory == null) throw new ArgumentNullException(nameof(fixtureFactory));
            this.dataOfT1 = dataOfT1;
            this.dataOfT2 = dataOfT2;
            this.dataOfT3 = dataOfT3;
            this.dataOfT4 = dataOfT4;

            this.fixtureLazy = new Lazy<IFixture>(fixtureFactory, LazyThreadSafetyMode.PublicationOnly);
        }

        public override IEnumerable<(T1, T2, T3, T4)> GenerateDataSources(DataGeneratorMetadata metadata)
        {
            ArgumentNullException.ThrowIfNull(metadata.ParameterInfos);
            if (metadata.ParameterInfos.Length == 0)
            {
                return Enumerable.Empty<(T1, T2, T3, T4)>();
            }
            // todo: validate parameterinfos against generic types
            var parameters = new ParameterMetadata[metadata.ParameterInfos.Length];
            
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[0], ref parameters[0], this.dataOfT1);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[1], ref parameters[1], this.dataOfT2);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[2], ref parameters[2], this.dataOfT3);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[3], ref parameters[3], this.dataOfT4);
            
            object[] dataSources = DataSourceGenerator.GenerateDataSources(parameters, this.fixtureLazy.Value);

            return [((T1)dataSources[0], (T2)dataSources[1], (T3)dataSources[2], (T4)dataSources[3])];
        }
    }
    
    /// <summary>
    /// Provides a data source for a data theory, with the data coming from inline
    /// values combined with auto-generated data specimens generated by AutoFixture.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    [CLSCompliant(false)]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes",
        Justification = "This attribute is the root of a potential attribute hierarchy.")]
    [SuppressMessage("Usage", "TUnit0028:AttributeUsage Overridden")]
    public class InlineAutoDataAttribute<T1, T2, T3, T4, T5> : DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
    {
        private readonly T3? dataOfT3;
        private readonly T4? dataOfT4;
        private readonly T5? dataOfT5;
        private readonly T1? dataOfT1;
        private readonly T2? dataOfT2;
        private readonly Lazy<IFixture> fixtureLazy;

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This constructor overload initializes the <see cref="Fixture"/> to an instance of
        /// <see cref="Fixture"/>.
        /// </para>
        /// </remarks>
        public InlineAutoDataAttribute(T1? dataOfT1 = default, T2? dataOfT2 = default, T3? dataOfT3 = default, T4? dataOfT4 = default, T5? dataOfT5 = default)
            : this(() => new Fixture(), dataOfT1, dataOfT2, dataOfT3)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoDataAttribute{T}"/> class
        /// with the supplied <paramref name="fixtureFactory"/>. Fixture will be created
        /// on demand using the provided factory.
        /// </summary>
        /// <param name="fixtureFactory">The fixture factory used to construct the fixture.</param>
        /// <param name="dataOfT1"></param>
        /// <param name="dataOfT2"></param>
        protected InlineAutoDataAttribute(Func<IFixture> fixtureFactory, T1? dataOfT1 = default, T2? dataOfT2 = default, T3? dataOfT3 = default, T4? dataOfT4 = default, T5? dataOfT5 = default)
        {
            if (fixtureFactory == null) throw new ArgumentNullException(nameof(fixtureFactory));
            this.dataOfT1 = dataOfT1;
            this.dataOfT2 = dataOfT2;
            this.dataOfT3 = dataOfT3;
            this.dataOfT4 = dataOfT4;
            this.dataOfT5 = dataOfT5;

            this.fixtureLazy = new Lazy<IFixture>(fixtureFactory, LazyThreadSafetyMode.PublicationOnly);
        }

        public override IEnumerable<(T1, T2, T3, T4, T5)> GenerateDataSources(DataGeneratorMetadata metadata)
        {
            ArgumentNullException.ThrowIfNull(metadata.ParameterInfos);
            if (metadata.ParameterInfos.Length == 0)
            {
                return Enumerable.Empty<(T1, T2, T3, T4, T5)>();
            }
            // todo: validate parameterinfos against generic types
            var parameters = new ParameterMetadata[metadata.ParameterInfos.Length];
            
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[0], ref parameters[0], this.dataOfT1);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[1], ref parameters[1], this.dataOfT2);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[2], ref parameters[2], this.dataOfT3);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[3], ref parameters[3], this.dataOfT4);
            DataSourceGenerator.SetMetadata(metadata.ParameterInfos[4], ref parameters[4], this.dataOfT5);
            
            object[] dataSources = DataSourceGenerator.GenerateDataSources(parameters, this.fixtureLazy.Value);

            return [((T1)dataSources[0], (T2)dataSources[1], (T3)dataSources[2], (T4)dataSources[3], (T5)dataSources[4])];
        }
    }
}
